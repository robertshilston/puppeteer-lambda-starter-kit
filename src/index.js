const setup = require('./starter-kit/setup');
const lighthouse = require('lighthouse');
const url = require('url');
const AWS = require('aws-sdk');
const dynamoDb = new AWS.DynamoDB.DocumentClient();

module.exports.handler = async (event, context, callback) => {
// For keeping the browser launch
  context.callbackWaitsForEmptyEventLoop = false;
  const browser = await setup.getBrowser();

  let response = {
    statusCode: 200,
    headers: {
      'Access-Control-Allow-Origin': '*', // Required for CORS support to work
    },
  };

  // Allow the URL to be specified either via query string or a direct
  // argument on the lambda invocation - that is, either:
  // https://XX.execute-api.YY.amazonaws.com/ZZ?url=https://ft.com/
  // or
  // aws lambda invoke --invocation-type RequestResponse \
  // --function-name puppeteer-lambda-starter-kit-dev-test-function \
  // --region eu-west-1 --log-type Tail \
  // --payload '{"url": "http://ft.com"}' out.txt

  let requesturls;

  if (event.queryStringParameters && event.queryStringParameters.url) {
    requesturls = event.queryStringParameters.url;
  }

  if (event.url) {
    requesturls = event.url;
  }

  // As execution might exceed the HTTP 30 sec timeout from API gateway
  // or we might have a batch, then re-execute myself asynchronously.
  if (!Array.isArray(requesturls)) requesturls = [requesturls];

  if (requesturls.length > 1 || event.queryStringParameters) {
    const lambda = new AWS.Lambda();

    let LambdaPromises = requesturls.map( function(url) {
      let newpayload = {'url': url};
      let params = {
        FunctionName: context.functionName,
        InvocationType: 'Event',
        Payload: JSON.stringify(newpayload),
        Qualifier: context.functionVersion,
      };
      console.log('Invoking sub-lambda for ' + url);

      return lambda.invoke(params, context.done).promise();
    });

    try {
      res = await Promise.all(LambdaPromises);
    } catch (e) {
      res = e;
    }
    console.log('Result of batch lambda requests is: ');
    console.log(JSON.stringify(res));

    response.body = 'Forked ' + requesturls.length + ' process(es)';
    callback(null, response);
  } else {
    // Just one URL to process:
    let thisurl = requesturls[0];
    console.log('Auditing ' + thisurl);

    const result = await exports.getFinishedPage(browser, thisurl);
    response.body = JSON.stringify(result);
    callback(null, response);
  }
};


exports.getFinishedPage = async (browser, pageurl) => {
  let response = {};

  if (!pageurl) {
    response.message = 'No URL supplied: you must specifiy the page to audit.';
    console.log(response.message);
    return response;
  }

  /* Chunk 1: Do Chrome Lighthouse report */
  let wsep = browser.wsEndpoint();
  let wsepport = url.parse(wsep).port;

  // Use timestamp in seconds rather than milliseconds, to aid subsequent re-use
  const timestamp = new Date().getTime()/1000;

  const lhr = await lighthouse(pageurl, {
    port: wsepport,
    output: 'json',
    logLevel: 'none',
  });

  // Get scores
  let scorecard = {
    'url': pageurl,
    'scantimestamp': timestamp,
  };
  lhr.reportCategories.map((c) => {
    if (c.id=='best-practices') c.id='bestpractices';
    scorecard[c.id] = c.score;
  });
  response.lighthousescores = scorecard;


  /* Chunk 2: Load the page and do our own additional bits */
  // Load the target web page.
  const page = await browser.newPage();
  await page.goto(pageurl,
    {waitUntil: ['domcontentloaded', 'networkidle0']}
  );

  response.pageTitle = await page.title();
  scorecard['cookies'] = await page.cookies();
  scorecard['pagetitle'] = response.pageTitle;

  // Push to s3:
  let s3 = new AWS.S3({apiVersion: '2006-03-01', region: 'eu-west-1'});
  let params = {
    Bucket: 'lighthouse-audit-scorecard',
    Key: 'scorecard/' + timestamp + '-' + encodeURIComponent(pageurl) + '.json',
    Body: JSON.stringify(scorecard),
  };

  await s3.putObject(params).promise();

  params = {
    Bucket: 'lighthouse-audit-scorecard',
    Key: 'full/' + timestamp + '-' + encodeURIComponent(pageurl) + '.json',
    Body: JSON.stringify(lhr),
  };

  await s3.putObject(params).promise();

  // The artifacts generated by lighthouse are larger than Dynamo's 400KB limit
  delete lhr.artifacts;

  // Push to DynamoDB:
  if (process.env.DYNAMODB_TABLE) {
    console.log('Attempting to store in DB');
    let params = {
      TableName: process.env.DYNAMODB_TABLE,
      Item: scorecard,
    };
    let res = await dynamoDb.put(params).promise();
    console.log('Res: ' + JSON.stringify(res));

    // params.Item['fullreport'] = lhr;
  } else {
    console.warn('Not writing to DB as no table name specified');
  }

  return response;
};

