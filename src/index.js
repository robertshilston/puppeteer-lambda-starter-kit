const setup = require('./starter-kit/setup');
const lighthouse = require('lighthouse');
const url = require('url');
const AWS = require('aws-sdk');
const dynamoDb = new AWS.DynamoDB.DocumentClient();

module.exports.handler = async (event, context, callback) => {
// For keeping the browser launch
  context.callbackWaitsForEmptyEventLoop = false;
  const browser = await setup.getBrowser();

  let response = {
    statusCode: 200,
    headers: {
      'Access-Control-Allow-Origin': '*', // Required for CORS support to work
    },
  };

  // Allow the URL to be specified either via query string or a direct
  // argument on the lambda invocation - that is, either:
  // https://XX.execute-api.YY.amazonaws.com/ZZ?url=https://ft.com/
  // or
  // aws lambda invoke --invocation-type RequestResponse \
  // --function-name puppeteer-lambda-starter-kit-dev-test-function \
  // --region eu-west-1 --log-type Tail \
  // --payload '{"url": "http://ft.com"}' out.txt

  let requesturls;

  if (event.queryStringParameters && event.queryStringParameters.url) {
    requesturls = event.queryStringParameters.url;
  }

  if (event.url) {
    requesturls = event.url;
  }

  // As execution might exceed the HTTP 30 sec timeout from API gateway
  // or we might have a batch, then re-execute myself asynchronously.
  if (!Array.isArray(requesturls)) requesturls = [requesturls];

  if (requesturls.length > 1 || event.queryStringParameters) {
    const lambda = new AWS.Lambda();

    let LambdaPromises = requesturls.map( function(url) {
      let newpayload = {'url': url};
      let params = {
        FunctionName: context.functionName,
        InvocationType: 'Event',
        Payload: JSON.stringify(newpayload),
        Qualifier: context.functionVersion,
      };
      console.log('Invoking sub-lambda for ' + url);

      return lambda.invoke(params, context.done).promise();
    });

    try {
      res = await Promise.all(LambdaPromises);
    } catch (e) {
      res = e;
    }
    console.log('Result of batch lambda requests is: ');
    console.log(JSON.stringify(res));

    response.body = 'Forked ' + requesturls.length + ' process(es)';
    callback(null, response);
  } else {
    // Just one URL to process:
    let thisurl = requesturls[0];
    console.log('Auditing ' + thisurl);

    const result = await exports.getFinishedPage(browser, thisurl);
    response.body = JSON.stringify(result);
    callback(null, response);
  }
};


exports.getFinishedPage = async (browser, pageurl) => {
  let response = {};

  if (!pageurl) {
    response.message = 'No URL supplied: you must specifiy the page to audit.';
    console.log(response.message);
    return response;
  }

  let wsep = browser.wsEndpoint();
  let wsepport = url.parse(wsep).port;

  const timestamp = new Date().getTime();

  const lhr = await lighthouse(pageurl, {
    port: wsepport,
    output: 'json',
    logLevel: 'none',
  });

  // The artifacts generated by lighthouse are larger than Dynamo's 400KB limit
  delete lhr.artifacts;

  let scorecard = lhr.reportCategories.map((c) => {
    let r = {};
    r[c.id] = c.score;
    return r;
  });
  console.log(scorecard);
  response.lighthousescores = scorecard;

  // Push to DynamoDB:
  if (process.env.DYNAMODB_TABLE) {
    console.log('Attempting to store in DB');
    let params = {
      TableName: process.env.DYNAMODB_TABLE,
      Item: {
        url: pageurl,
        scantimestamp: timestamp,
        scores: scorecard,
      },
    };
    console.log(params);
    let res = await dynamoDb.put(params).promise();
    console.log('Res: ' + res);

    // params.Item['fullreport'] = lhr;
  } else {
    console.warn('Not writing to DB as no table name specified');
  }

  return response;
};

